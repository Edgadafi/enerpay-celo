{
  "contractAddress": "0xB35aB84408E28D0B81205293Dd2ed1d6E8566f1e",
  "compilerVersion": "0.8.20",
  "optimizer": {
    "enabled": true,
    "runs": 200
  },
  "constructorArguments": "000000000000000000000000765de816845861e75a25fca122bb6898b8b1282a000000000000000000000000856ff827a04ee1de5576e3d21e1985bd76fb24e7",
  "constructorArgsFormatted": "0x000000000000000000000000765de816845861e75a25fca122bb6898b8b1282a000000000000000000000000856ff827a04ee1de5576e3d21e1985bd76fb24e7",
  "license": "MIT",
  "sourceCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title EnerpayRemittance\n * @notice Smart contract for handling remittances on Celo using cUSD\n * @dev Allows users to send remittances with platform fees and tracking\n */\ncontract EnerpayRemittance is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    \n    // ============ State Variables ============\n    \n    /// @notice cUSD token contract address\n    IERC20 public cUSD;\n    \n    /// @notice Treasury address for collecting platform fees\n    address public treasuryAddress;\n    \n    /// @notice Platform fee in basis points (150 = 1.5%)\n    uint256 public platformFee = 150;\n    \n    /// @notice Mapping of remittance ID to Remittance struct\n    mapping(uint256 => Remittance) public remittances;\n    \n    /// @notice Counter for remittance IDs\n    uint256 public remittanceCount;\n    \n    /// @notice Mapping of user address to array of remittance IDs\n    mapping(address => uint256[]) public userRemittances;\n    \n    // ============ Structs ============\n    \n    /**\n     * @notice Remittance data structure\n     * @param sender Address of the sender\n     * @param beneficiary Address of the beneficiary\n     * @param amount Amount in cUSD (without fees)\n     * @param destinationType Type of destination (e.g., \"wallet\", \"bank\", \"mobile\")\n     * @param destinationId Identifier for the destination\n     * @param timestamp When the remittance was created\n     * @param status Current status of the remittance\n     */\n    struct Remittance {\n        address sender;\n        address beneficiary;\n        uint256 amount;\n        string destinationType;\n        string destinationId;\n        uint256 timestamp;\n        RemittanceStatus status;\n    }\n    \n    // ============ Enums ============\n    \n    /**\n     * @notice Status of a remittance\n     */\n    enum RemittanceStatus {\n        Pending,    // Remittance created but not completed\n        Completed,  // Remittance successfully completed\n        Failed,     // Remittance failed\n        Refunded    // Remittance refunded to sender\n    }\n    \n    // ============ Events ============\n    \n    /**\n     * @notice Emitted when a new remittance is created\n     * @param remittanceId Unique identifier for the remittance\n     * @param sender Address of the sender\n     * @param beneficiary Address of the beneficiary\n     * @param amount Amount in cUSD\n     * @param fee Platform fee charged\n     * @param destinationType Type of destination\n     * @param destinationId Identifier for the destination\n     */\n    event RemittanceCreated(\n        uint256 indexed remittanceId,\n        address indexed sender,\n        address indexed beneficiary,\n        uint256 amount,\n        uint256 fee,\n        string destinationType,\n        string destinationId\n    );\n    \n    /**\n     * @notice Emitted when a remittance is completed\n     * @param remittanceId Unique identifier for the remittance\n     * @param status Final status of the remittance\n     */\n    event RemittanceCompleted(\n        uint256 indexed remittanceId,\n        RemittanceStatus status\n    );\n    \n    // ============ Modifiers ============\n    \n    /**\n     * @notice Ensures the remittance exists\n     */\n    modifier remittanceExists(uint256 _remittanceId) {\n        require(_remittanceId < remittanceCount, \"Remittance does not exist\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    /**\n     * @notice Initializes the contract\n     * @param _cUSD Address of the cUSD token contract\n     * @param _treasuryAddress Address where platform fees will be sent\n     */\n    constructor(address _cUSD, address _treasuryAddress) Ownable(msg.sender) {\n        require(_cUSD != address(0), \"Invalid cUSD address\");\n        require(_treasuryAddress != address(0), \"Invalid treasury address\");\n        \n        cUSD = IERC20(_cUSD);\n        treasuryAddress = _treasuryAddress;\n    }\n    \n    // ============ External Functions ============\n    \n    /**\n     * @notice Sends a remittance\n     * @param _beneficiary Address of the beneficiary\n     * @param _amount Amount in cUSD (without fees)\n     * @param _destinationType Type of destination (e.g., \"wallet\", \"bank\", \"mobile\")\n     * @param _destinationId Identifier for the destination\n     * @return remittanceId Unique identifier for the created remittance\n     */\n    function sendRemittance(\n        address _beneficiary,\n        uint256 _amount,\n        string memory _destinationType,\n        string memory _destinationId\n    ) external nonReentrant returns (uint256) {\n        require(_beneficiary != address(0), \"Invalid beneficiary address\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(\n            bytes(_destinationType).length > 0,\n            \"Destination type cannot be empty\"\n        );\n        \n        // Calculate platform fee\n        uint256 fee = (_amount * platformFee) / 10000;\n        uint256 totalAmount = _amount + fee;\n        \n        // Transfer cUSD from user to contract\n        cUSD.safeTransferFrom(msg.sender, address(this), totalAmount);\n        \n        // Create remittance record\n        uint256 remittanceId = remittanceCount;\n        remittances[remittanceId] = Remittance({\n            sender: msg.sender,\n            beneficiary: _beneficiary,\n            amount: _amount,\n            destinationType: _destinationType,\n            destinationId: _destinationId,\n            timestamp: block.timestamp,\n            status: RemittanceStatus.Pending\n        });\n        \n        // Add to user's remittance history\n        userRemittances[msg.sender].push(remittanceId);\n        \n        remittanceCount++;\n        \n        // Transfer fee to treasury\n        if (fee > 0) {\n            // Verify contract has sufficient balance before transferring fee\n            uint256 contractBalance = cUSD.balanceOf(address(this));\n            require(contractBalance >= fee, \"Insufficient contract balance for fee transfer\");\n            cUSD.safeTransfer(treasuryAddress, fee);\n        }\n        \n        // If wallet-to-wallet, transfer immediately\n        if (\n            keccak256(bytes(_destinationType)) ==\n            keccak256(bytes(\"wallet\"))\n        ) {\n            cUSD.safeTransfer(_beneficiary, _amount);\n            remittances[remittanceId].status = RemittanceStatus.Completed;\n            \n            emit RemittanceCompleted(\n                remittanceId,\n                RemittanceStatus.Completed\n            );\n        }\n        \n        emit RemittanceCreated(\n            remittanceId,\n            msg.sender,\n            _beneficiary,\n            _amount,\n            fee,\n            _destinationType,\n            _destinationId\n        );\n        \n        return remittanceId;\n    }\n    \n    /**\n     * @notice Completes a remittance (only owner)\n     * @param _remittanceId ID of the remittance to complete\n     * @param _status Final status (Completed, Failed, or Refunded)\n     */\n    function completeRemittance(\n        uint256 _remittanceId,\n        RemittanceStatus _status\n    ) external onlyOwner remittanceExists(_remittanceId) {\n        Remittance storage remittance = remittances[_remittanceId];\n        \n        require(\n            remittance.status == RemittanceStatus.Pending,\n            \"Remittance already processed\"\n        );\n        require(\n            _status == RemittanceStatus.Completed ||\n                _status == RemittanceStatus.Failed ||\n                _status == RemittanceStatus.Refunded,\n            \"Invalid status\"\n        );\n        \n        remittance.status = _status;\n        \n        if (_status == RemittanceStatus.Completed) {\n            // Transfer amount to beneficiary\n            cUSD.safeTransfer(remittance.beneficiary, remittance.amount);\n        } else if (_status == RemittanceStatus.Refunded) {\n            // Refund amount to sender\n            cUSD.safeTransfer(remittance.sender, remittance.amount);\n        }\n        // If Failed, amount stays in contract (can be handled separately)\n        \n        emit RemittanceCompleted(_remittanceId, _status);\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Gets remittance history for a user\n     * @param _user Address of the user\n     * @return Array of remittance IDs belonging to the user\n     */\n    function getRemittanceHistory(\n        address _user\n    ) external view returns (uint256[] memory) {\n        return userRemittances[_user];\n    }\n    \n    /**\n     * @notice Gets details of a specific remittance\n     * @param _remittanceId ID of the remittance\n     * @return Remittance struct with all details\n     */\n    function getRemittance(\n        uint256 _remittanceId\n    ) external view remittanceExists(_remittanceId) returns (Remittance memory) {\n        return remittances[_remittanceId];\n    }\n    \n    /**\n     * @notice Calculates the platform fee for a given amount\n     * @param _amount Amount in cUSD\n     * @return fee Calculated fee\n     * @return totalAmount Total amount including fee\n     */\n    function calculateFee(\n        uint256 _amount\n    ) external view returns (uint256 fee, uint256 totalAmount) {\n        fee = (_amount * platformFee) / 10000;\n        totalAmount = _amount + fee;\n    }\n    \n    // ============ Owner Functions ============\n    \n    /**\n     * @notice Updates the platform fee (only owner)\n     * @param _newFee New fee in basis points (e.g., 150 = 1.5%)\n     */\n    function setPlatformFee(uint256 _newFee) external onlyOwner {\n        require(_newFee <= 1000, \"Fee cannot exceed 10%\");\n        platformFee = _newFee;\n    }\n    \n    /**\n     * @notice Updates the treasury address (only owner)\n     * @param _newTreasury New treasury address\n     */\n    function setTreasuryAddress(address _newTreasury) external onlyOwner {\n        require(_newTreasury != address(0), \"Invalid treasury address\");\n        treasuryAddress = _newTreasury;\n    }\n    \n    /**\n     * @notice Emergency function to withdraw stuck funds (only owner)\n     * @param _amount Amount to withdraw\n     * @param _to Address to send funds to\n     */\n    function emergencyWithdraw(\n        uint256 _amount,\n        address _to\n    ) external onlyOwner {\n        require(_to != address(0), \"Invalid address\");\n        cUSD.safeTransfer(_to, _amount);\n    }\n}\n\n"
}